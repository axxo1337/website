export const metadata = {
    title: "Virtual Memory Explained",
    description: "What are memory pages? What exactly is an address space? Well that's what you'll learn today!",
    createdAt: "2025-12-22",
    updatedAt: "2025-12-22",
    youtubeId: "ultz9m0n0GE",
    thumbnailPath: "/images/thumbnails/virtual-memory-explained.png"
};

Nowadays it's not uncommon for computers to be running hundreds of processes at a time. By this fact two major concerns 
arise: security and resource management. On one hand each application should be mostly isolated one from another. 
You wouldn't want [Notion](https://notion.so) to be spying on what tabs are open in your [Chrome](https://www.google.com/intl/en_ca/chrome/) browser. And on the other you might be 
running these applications on an old laptop which doesn't have enough RAM to handle all of them at once.
<br />
These are the problems virtual memory solves. And that's what this video explains. I recommend you first give it a watch 
and come back here afterwards to read my written explanation. Although note that I've made some very slight mistakes here 
and there in said video. Thankfully these were all clarified in a comment I made and pinned in the comments section of 
said video.
<br />
Just for good measure I'll correct them here as well, but feel free to skip this list and watch the video, or maybe simply 
get on with the first chapter of this document:
1. I misspelled the Level 4 Page Map Table as "PLM4" instead of PML4 throughout the video.
2. At [6:15](https://youtube.com/watch?v=ultz9m0n0GE&t=375s&pp=0gcJCTAAlc8ueATH) I wrote 412 by accident. The number 
should be 512.
3. I realized just now that my illustration of page sizes might have been confusing. Regular pages are of 4KB which 
is 4096 bytes. Not 4096KB (just to be crystal clear)
4. The table entries contain a bit called the "present" bit (the rightmost bit). It's called that because as 
long as it is 1 it means the page is in memory. As soon as it is 0 it means the page is on disk, and when it is on 
disk the bits used for the physical page index are used to locate the page on disk instead.

### What is memory?

Memory is not an easy thing to define as it exists in *many* forms. Although all formats of memory share one common property:
they're all states of disturbance in matter. For example, hard drives store data on magnetic disks by changing the orientation of
tiny magnetic fields on the disks' surface. Then it can read the data back by measuring the orientation of these fields.
<br />
Electronics only care about two states of disturbance. That's why it's well known that computers operate in binary. Binary 
comes from the word bini in latin meaning two. I could say that the decision of whether or not I shall go to the park is binary,
because it's composed of only two possible choices.
<br />
My point is that when we refer to binary we can mean many things as long as they are directly related to the principle of two. For instance, binary is also a number system. You see, we
were taught to count in a number system called base ten (decimal). It consists of 10 possible distinct digits from which we can derive
infinitely many numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9. Binary on the other hand is base 2. Its numbers can only consist of the digits 0 and 1.
<br />
But that's not the only property we can discern between number bases. Let's start by taking the decimal number 11, but put in binary:
```math
(1011)_2
```
The parentheses and the suffix 2 is to let us know that the number is specifically in base 2 (binary) and not the decimal number 1011. So how do we convert this back to base 10?
To do so we'll need to read the number from right to left, convert each digit to its decimal value and sum all of the results together.

![Binary number powers](/images/documents/virtual-memory-explained/binary_powers.png)

In the above illustration I assigned the appropriate index to each digit of the concerned binary number from right to left starting from 0. This is a very important step because
each one of these indices represent the power of the digit at said position. Since we're working with base two, the power is $2^n$, where n is said index. The digit itself represents
the product by which we multiply the result of that power. Here's a full depiction below:

![Binary results](/images/documents/virtual-memory-explained/binary_results.png)

The result would be:
```math
\begin{align*}
&\phantom{=} 1 \times 2^0 + 1 \times 2^1 + 0 \times 2^2 + 1 \times 2^3 \\
&= 1 + 2 + 0 + 8 \\
&= 11
\end{align*}
```

A single binary digit is called a bit. The number we were working with was 4 bits. Bits are a unit of measurement used to quantify memory just like you use centimeters to quantify
length. And just like such measurements we have other names to simplify larger values. In the case of bits we have bytes. One byte is 8 bits. Then for 2 bytes, or 16 bits,
there is the word (it's literally called word). Here's a depiction of these measurements:

![Memory scale](/images/documents/virtual-memory-explained/memory_scale.png)

The format of memory we'll mostly care about today is random access memory (RAM). This medium is volatile meaning the method it uses to read and write bits is temporary. When you 
cut the power to your machine all of its contents are lost. It's also the second fastest storage format in computers after in-processor memory, and that's where programs are
stored while executing.

<br />

So how is your computer able to tell which parts of RAM it should access when it needs to read or write anything? It uses something known as addressing. Every single byte in 
memory has its own unique address, like houses on a street. Address 0 would lead to the first byte in memory, and address 1 to the second.

![Example addressing](/images/documents/virtual-memory-explained/example_addressing.png)

The figure above provides an example of memory addressing. Each row consists of a byte (8 bits) and is indexed as such (row 1 is 0x0, row 2 is 0x1 and row 3 is 0x2). You may be 
wondering why we prefix each address by "0x". That's because these numbers are in a base called hexadecimal. We won't dive into the details, but essentially when working with
addresses we often express them in terms of hexadecimal numbers rather than decimal as they can get pretty large, and base 16 supporting 16 different digits per power it tends
to make the numbers look much simpler. "0x" is just a prefix to make it clear the base is 16. Thankfully in this case the numbers translate directly to decimal since they don't
go above 9 and remain in the first power.

<br />

How can hexadecimal support this many digits if we only know up to 9? It uses the alphabet. Here are all the possible digits: 0, 1,
2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F, where F equals 15 in decimal.

### Memory paging

Imagine your computer only had 28 kilobytes of RAM. You decide to open Discord and Minecraft so you can play bedwars with your friends. The thing is, you remember it's 
the holidays and your friends are all busy. So you close Discord and open Chrome instead.

![Example scenario 1](/images/documents/virtual-memory-explained/scenario1.png)

As illustrated in the above figure there's an issue. Chrome requires too much memory to be placed where Discord was, and it can't possibly fit under Minecraft. So what would happen?
Well luckily virtual memory is enabled and so memory is divided in equal-sized 4 kilobytes chunks called pages (this scenario is theoretical and ignores the fact that the operating
system itself would also be taking up memory).

![Example scenario 1.1](/images/documents/virtual-memory-explained/scenario1-1.png)

The system can take the first two pages of Chrome, fit them where Discord was, and take the remaining page and fit it under Minecraft. That's memory paging. 

<br />

But what if that memory page couldn't fit under Minecraft because say the calculator app was using up said page.

### Memory tables

### Virtual address

### Identity mapping

### Translation look-aside buffer

### Why use all these tables?